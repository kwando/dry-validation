<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>dry-validation by dryrb</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">dry-validation</h1>
      <h2 class="project-tagline">Data validation library based on predicate logic and rule composition</h2>
      <a href="https://github.com/dryrb/dry-validation" class="btn">View on GitHub</a>
      <a href="https://github.com/dryrb/dry-validation/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/dryrb/dry-validation/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="dry-validation-" class="anchor" href="#dry-validation-" aria-hidden="true"><span class="octicon octicon-link"></span></a>dry-validation <a href="https://gitter.im/dryrb/chat"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/dryrb/chat"></a>
</h1>

<p><a href="https://rubygems.org/gems/dry-validation"><img src="https://badge.fury.io/rb/dry-validation.svg" alt="Gem Version"></a>
<a href="https://travis-ci.org/dryrb/dry-validation"><img src="https://travis-ci.org/dryrb/dry-validation.svg?branch=master" alt="Build Status"></a>
<a href="https://gemnasium.com/dryrb/dry-validation"><img src="https://gemnasium.com/dryrb/dry-validation.svg" alt="Dependency Status"></a>
<a href="https://codeclimate.com/github/dryrb/dry-validation"><img src="https://codeclimate.com/github/dryrb/dry-validation/badges/gpa.svg" alt="Code Climate"></a>
<a href="https://codeclimate.com/github/dryrb/dry-validation"><img src="https://codeclimate.com/github/dryrb/dry-validation/badges/coverage.svg" alt="Test Coverage"></a>
<a href="http://inch-ci.org/github/dryrb/dry-validation"><img src="http://inch-ci.org/github/dryrb/dry-validation.svg?branch=master" alt="Inline docs"></a></p>

<p>Data validation library based on predicate logic and rule composition.</p>

<h2>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Unlike other, well known, validation solutions in Ruby, <code>dry-validation</code> takes
a different approach and focuses a lot on explicitness, clarity and preciseness
of validation logic. It is designed to work with any data input, whether it's a
simple hash, an array or a complex object with deeply nested data.</p>

<p>It is based on a simple idea that each validation is encapsulated by a simple,
stateless predicate, that receives some input and returns either <code>true</code> or <code>false</code>.</p>

<p>Those predicates are encapsulated by <code>rules</code> which can be composed together using
<code>predicate logic</code>. This means you can use the common logic operators to build up
a validation <code>schema</code>.</p>

<p>It's very explicit, powerful and extendible.</p>

<p>Validations can be described with great precision, <code>dry-validation</code> eliminates
ambigious concepts like <code>presence</code> validation where we can't really say whether
some attribute or key is <em>missing</em> or it's just that the value is <code>nil</code>.</p>

<p>There's also the concept of type-safety, completely missing in other validation
libraries, which is quite important and useful. It means you can compose a validation
that does rely on the type of a given value. In example it makes no sense to validate
each element of an array when it turns out to be an empty string.</p>

<h2>
<a id="the-dsl" class="anchor" href="#the-dsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>The DSL</h2>

<p>The core of <code>dry-validation</code> is rules composition and predicate logic. The DSL
is a simple front-end for that. It only allows you to define the rules by using
predicate identifiers. There are no magical options, conditionals and custom
validation blocks known from other libraries. The focus is on pure validation
logic.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<h3>
<a id="basic" class="anchor" href="#basic" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic</h3>

<p>Here's a basic example where we validate following things:</p>

<ul>
<li>The input <em>must have a key</em> called <code>:email</code>

<ul>
<li>Provided the email key is present, its value <em>must be filled</em>
</li>
</ul>
</li>
<li>The input <em>must have a key</em> called <code>:age</code>

<ul>
<li>Provided the age key is present, its value <em>must be an integer</em> and it <em>must be greater than 18</em>
</li>
</ul>
</li>
</ul>

<p>This can be easily expressed through the DSL:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">email</span>| email.filled? }

  key(<span class="pl-c1">:age</span>) <span class="pl-k">do </span>|<span class="pl-smi">age</span>|
    age.int? <span class="pl-k">&amp;</span> age.gt?(<span class="pl-c1">18</span>)
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-s"><span class="pl-pds">'</span>jane@doe.org<span class="pl-pds">'</span></span>, <span class="pl-c1">age:</span> <span class="pl-c1">19</span>)

puts errors.inspect
<span class="pl-c"># []</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">email:</span> <span class="pl-c1">nil</span>, <span class="pl-c1">age:</span> <span class="pl-c1">19</span>)

puts errors.inspect
<span class="pl-c"># [[:email, ["email must be filled"]]]</span></pre></div>

<p>A couple of remarks:</p>

<ul>
<li>
<code>key</code> assumes that we want to use the <code>:key?</code> predicate to check the existance of that key</li>
<li>
<code>age.gt?(18)</code> translates to calling a predicate like this: <code>schema[:gt?].(18, age)</code>
</li>
<li>
<code>age.int? &amp; age.gt?(18)</code> is a conjunction, so we don't bother about <code>gt?</code> unless <code>int?</code> returns <code>true</code>
</li>
<li>You can also use <code>|</code> for disjunction</li>
<li>Schema object does not carry the input as its state, nor does it know how to access the input values, we
pass the input to <code>call</code> and get error set as the response</li>
</ul>

<h3>
<a id="nested-hash" class="anchor" href="#nested-hash" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Hash</h3>

<p>We are free to define validations for anything, including deeply nested structures:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">require</span> <span class="pl-s"><span class="pl-pds">'</span>dry-validation<span class="pl-pds">'</span></span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:address</span>) <span class="pl-k">do </span>|<span class="pl-smi">address</span>|
    address.key(<span class="pl-c1">:city</span>) <span class="pl-k">do </span>|<span class="pl-smi">city</span>|
      city.min_size?(<span class="pl-c1">3</span>)
    <span class="pl-k">end</span>

    address.key(<span class="pl-c1">:street</span>) <span class="pl-k">do </span>|<span class="pl-smi">street</span>|
      street.filled?
    <span class="pl-k">end</span>

    address.key(<span class="pl-c1">:country</span>) <span class="pl-k">do </span>|<span class="pl-smi">country</span>|
      country.key(<span class="pl-c1">:name</span>, <span class="pl-k">&amp;</span><span class="pl-c1">:filled?</span>)
      country.key(<span class="pl-c1">:code</span>, <span class="pl-k">&amp;</span><span class="pl-c1">:filled?</span>)
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

schema <span class="pl-k">=</span> <span class="pl-c1">Schema</span>.<span class="pl-k">new</span>

errors <span class="pl-k">=</span> schema.messages({})

puts errors.inspect
<span class="pl-c"># [[:address, ["address is missing"]]]</span>

errors <span class="pl-k">=</span> schema.messages(<span class="pl-c1">address:</span> { <span class="pl-c1">city:</span> <span class="pl-s"><span class="pl-pds">'</span>NYC<span class="pl-pds">'</span></span> })

puts errors.inspect
<span class="pl-c"># [[:address, [[:street, ["street is missing"]], [:country, ["country is missing"]]]]]</span></pre></div>

<h3>
<a id="defining-custom-predicates" class="anchor" href="#defining-custom-predicates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Defining Custom Predicates</h3>

<p>You can simply define predicate methods on your schema object:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">value</span>| value.str? <span class="pl-k">&amp;</span> value.email? }

  <span class="pl-k">def</span> <span class="pl-en">email?</span>(<span class="pl-smi">value</span>)
    <span class="pl-k">!</span> <span class="pl-k">/</span>magical<span class="pl-k">-</span>regex<span class="pl-k">-</span>that<span class="pl-k">-</span>matches<span class="pl-k">-</span>emails<span class="pl-k">/</span>.match(value).nil?
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>You can also re-use a predicate container across multiple schemas:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">module</span> <span class="pl-en">MyPredicates</span>
  <span class="pl-k">include</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Predicates</span>

  predicate(<span class="pl-c1">:email?</span>) <span class="pl-k">do </span>|<span class="pl-smi">input</span>|
    <span class="pl-k">!</span> <span class="pl-k">/</span>magical<span class="pl-k">-</span>regex<span class="pl-k">-</span>that<span class="pl-k">-</span>matches<span class="pl-k">-</span>emails<span class="pl-k">/</span>.match(value).nil?
  <span class="pl-k">end</span>
<span class="pl-k">end</span>

<span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure <span class="pl-k">do </span>|<span class="pl-smi">config</span>|
    config.predicates <span class="pl-k">=</span> <span class="pl-c1">MyPredicates</span>
  <span class="pl-k">end</span>

  key(<span class="pl-c1">:email</span>) { |<span class="pl-smi">value</span>| value.str? <span class="pl-k">&amp;</span> value.email? }
<span class="pl-k">end</span></pre></div>

<h2>
<a id="list-of-built-in-predicates" class="anchor" href="#list-of-built-in-predicates" aria-hidden="true"><span class="octicon octicon-link"></span></a>List of Built-In Predicates</h2>

<ul>
<li><code>empty?</code></li>
<li><code>eql?</code></li>
<li><code>exclusion?</code></li>
<li><code>filled?</code></li>
<li><code>format?</code></li>
<li><code>gt?</code></li>
<li><code>gteq?</code></li>
<li><code>inclusion?</code></li>
<li><code>int?</code></li>
<li><code>key?</code></li>
<li><code>lt?</code></li>
<li><code>lteq?</code></li>
<li><code>max_size?</code></li>
<li><code>min_size?</code></li>
<li><code>nil?</code></li>
<li><code>size?</code></li>
<li><code>str?</code></li>
</ul>

<h2>
<a id="error-messages" class="anchor" href="#error-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Error Messages</h2>

<p>By default <code>dry-validation</code> comes with a set of pre-defined error messages for
every built-in predicate. They are defined in <a href="https://github.com/dryrb/dry-validation/blob/master/config/errors.yml">a yaml file</a>
which is shipped with the gem.</p>

<p>You can provide your own messages and configure your schemas to use it like that:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure { |<span class="pl-smi">config</span>| config.messages_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/path/to/my/errors.yml<span class="pl-pds">'</span></span> }
<span class="pl-k">end</span></pre></div>

<p>You can also provide a namespace per-schema that will be used by default:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">class</span> <span class="pl-en">Schema<span class="pl-e"> &lt; Dry::Validation::Schema</span></span>
  configure { |<span class="pl-smi">config</span>| config.namespace <span class="pl-k">=</span> <span class="pl-c1">:user</span> }
<span class="pl-k">end</span></pre></div>

<p>Lookup rules:</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>%{name} must be filled<span class="pl-pds">"</span></span></span>

<span class="pl-s"><span class="pl-ent">attributes:</span></span>
  <span class="pl-s"><span class="pl-ent">email:</span></span>
    <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>the email is missing<span class="pl-pds">"</span></span></span>

<span class="pl-s"><span class="pl-ent">user:</span></span>
  <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>%{name} name cannot be blank<span class="pl-pds">"</span></span></span>

  <span class="pl-s"><span class="pl-ent">attributes:</span></span>
    <span class="pl-s"><span class="pl-ent">address:</span></span>
      <span class="pl-s"><span class="pl-ent">filled?:</span> <span class="pl-s"><span class="pl-pds">"</span>You gotta tell us where you live<span class="pl-pds">"</span></span></span></pre></div>

<p>Given the yaml file above, messages lookup works as follows:</p>

<div class="highlight highlight-source-ruby"><pre>messages <span class="pl-k">=</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Messages</span>.load(<span class="pl-s"><span class="pl-pds">'</span>/path/to/our/errors.yml<span class="pl-pds">'</span></span>)

messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:age</span>) <span class="pl-c"># =&gt; "age must be filled"</span>
messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:address</span>) <span class="pl-c"># =&gt; "address must be filled"</span>
messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:email</span>) <span class="pl-c"># =&gt; "the email is missing"</span>

<span class="pl-c"># with namespaced messages</span>
user_messages <span class="pl-k">=</span> messages.namespaced(<span class="pl-c1">:user</span>)

user_messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:age</span>) <span class="pl-c"># "age cannot be blank"</span>
user_messages.lookup(<span class="pl-c1">:filled?</span>, <span class="pl-c1">:address</span>) <span class="pl-c"># "You gotta tell us where you live"</span></pre></div>

<p>By configuring <code>messages_file</code> and/or <code>namespace</code> in a schema, default messages
are going to be automatically merged with your overrides and/or namespaced.</p>

<h2>
<a id="i18n-integration" class="anchor" href="#i18n-integration" aria-hidden="true"><span class="octicon octicon-link"></span></a>I18n Integration</h2>

<p>Coming (very) soon...</p>

<h2>
<a id="rule-ast" class="anchor" href="#rule-ast" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rule AST</h2>

<p>Internally, <code>dry-validation</code> uses a simple AST representation of rules and errors
to produce rule objects and error messages. If you would like to programatically
generate rules, it is a very simple process:</p>

<div class="highlight highlight-source-ruby"><pre>ast <span class="pl-k">=</span> [
  [
    <span class="pl-c1">:and</span>,
    [
      [<span class="pl-c1">:key</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:key?</span>, []]]]],
      [
        <span class="pl-c1">:and</span>,
        [
          [<span class="pl-c1">:val</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:filled?</span>, []]]]],
          [<span class="pl-c1">:val</span>, [<span class="pl-c1">:age</span>, [<span class="pl-c1">:predicate</span>, [<span class="pl-c1">:gt?</span>, [<span class="pl-c1">18</span>]]]]]
        ]
      ]
    ]
  ]
]

compiler <span class="pl-k">=</span> <span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">RuleCompiler</span>.<span class="pl-k">new</span>(<span class="pl-c1">Dry</span>::<span class="pl-c1">Validation</span>::<span class="pl-c1">Predicates</span>)

<span class="pl-c"># compile an array of rule objects</span>
rules <span class="pl-k">=</span> compiler.call(ast)

puts rules.inspect
<span class="pl-c"># [</span>
<span class="pl-c">#   #&lt;Dry::Validation::Rule::Conjunction</span>
<span class="pl-c">#     left=#&lt;Dry::Validation::Rule::Key name=:age predicate=#&lt;Dry::Validation::Predicate id=:key?&gt;&gt;</span>
<span class="pl-c">#     right=#&lt;Dry::Validation::Rule::Conjunction</span>
<span class="pl-c">#       left=#&lt;Dry::Validation::Rule::Value name=:age predicate=#&lt;Dry::Validation::Predicate id=:filled?&gt;&gt;</span>
<span class="pl-c">#       right=#&lt;Dry::Validation::Rule::Value name=:age predicate=#&lt;Dry::Validation::Predicate id=:gt?&gt;&gt;&gt;&gt;</span>
<span class="pl-c"># ]</span>

<span class="pl-c"># dump it back to ast</span>
puts rules.map(<span class="pl-k">&amp;</span><span class="pl-c1">:to_ary</span>).inspect
<span class="pl-c"># [[:and, [:key, [:age, [:predicate, [:key?, [:age]]]]], [[:and, [:val, [:age, [:predicate, [:filled?, []]]]], [[:val, [:age, [:predicate, [:gt?, [18]]]]]]]]]]</span></pre></div>

<p>Complete docs for the AST format are coming soon, for now please refer to
<a href="https://github.com/dryrb/dry-validation/blob/master/spec/unit/rule_compiler_spec.rb">this spec</a>.</p>

<h2>
<a id="status-and-roadmap" class="anchor" href="#status-and-roadmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Status and Roadmap</h2>

<p>This library is in a very early stage of development but you are encauraged to
try it out and provide feedback.</p>

<p>For planned features check out <a href="https://github.com/dryrb/dry-validation/labels/feature">the issues</a>.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>See <code>LICENSE</code> file.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/dryrb/dry-validation">dry-validation</a> is maintained by <a href="https://github.com/dryrb">dryrb</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
